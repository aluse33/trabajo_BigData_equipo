---
title: "Lenguajes de programaci칩n: evoluci칩n y programaci칩n en Econom칤a"
description: |
  Lenguajes de programaci칩n m치s populares y los mejores para el an치lisis econ칩mico.
author:   
  - Alejandro Lucas (aluse@alumni.uv.es)\n   
  - Adri치n Guijarro (aguimar2@alumni.uv.es)\n
  - Luis D칤az (reyna@alumni.uv.es)\n
date: 2023-12-19                          
categories: [trabajo BigData, programaci칩n, R, econom칤a, modelos, macroeconom칤a, econometr칤a]   
image: "./imagenes/python_vs_r.png"
title-block-banner: "true" #- {true, false, "green","#AA0000"}
title-block-banner-color: "white"    #-"#FFFFFF" 
toc-depth: 3
smooth-scroll: true
format: 
  html:
    backgroundcolor: "#F1F3F4"
    #-embed-resources: true
    link-external-newwindow: true
    css: ./assets/my_css_file.css   #- CUIDADO!!!!
code-tools: true
code-link: true
---

```{r}
#| code-fold: true

#- Paquetes empleados en el trabajo:

library(tiobeindexr)
library(tidyverse)
library(gt)
library(RColorBrewer)
library(ggthemes)
library(highcharter)
library(gtExtras)
library(rio)
library(tidyr)
library(here)
library(readxl)
library(ggplot2)
library(dplyr)
library(readr)
library(reshape2)
library(stargazer)
library(vembedr)
library(rio)

```

## Introducci칩n

El objetivo del presente trabajo es hacer una revisi칩n sobre la evoluci칩n de la popularidad que tiene, en la actualidad, cada uno de los m치s famosos lenguajes de programaci칩n; asimismo, queremos hablar sobre la programaci칩n en Econom칤a, mostrando por qu칠 es fundamental manejar con cierta soltura un lenguaje (o m치s, preferiblemente), si uno busca ser un buen economista. Al final, esta es una asignatura 칰nica en el plan de estudios, que no solo sirve para darle una cantidad ingente de trabajo al profe o para que nosotros podamos evitar estudiar Sistema Tributario o Econom칤a Ambiental, sino para que podamos sintetizar en un an치lisis riguroso y reproducible todas esas teor칤as econ칩micas (y sus respectivos modelos) que estudiamos a lo largo del grado.

Primeramente, para estudiar la popularidad de los distintos lenguajes emplearemos el package `tiobeindexr`, el repo del paquete en CRAN est치 [aqu칤](https://cran.r-hub.io/web/packages/tiobeindexr/index.html), mientras que el repo del paquete en Github est치 [aqu칤](https://github.com/amrrs/tiobeindexr).

## An치lisis del 칈ndice TIOBE

El 칤ndice de la Comunidad de Programaci칩n de [TIOBE](https://www.tiobe.com/tiobe-index/) es un indicador de la popularidad de los lenguajes de programaci칩n, el cu치l es actualizado una vez al mes. Para calcular los ratings se basan en el n칰mero de b칰squedas en motores de busqueda populares(Google, Yahoo, Wikipedia, Youtube, etc) que incluyen el nombre de cada lenguaje de programaci칩n. Un aspecto que cabe resaltar es que el 칤ndice TIOBE no nos muestra cual es el mejor lenguaje de programaci칩n del mundo, ni siquiera cual es el lenguaje en el que se han escrito m치s l칤neas de codigo, pero si que nos ofrece informaci칩n acerca de si nuestras skills como programadores est치n actualizadas, o por el contrario, si debemos empezar a adoptar alg칰n nuevo lenguaje.

Una cosa que debemos matizar es que, debido a que hemos empleado el paquete `tiobeindexr`, que se actualiza peri칩dicamente, los resultados pueden cambiar (y seguramente hayan cambiado) en el momento en el que el lector est칠 leyendo esto, por lo que si decide descargarse el repo de nuestro trabajo y correr el c칩digo, los resultados pueden variar respecto a los que se pueden ver en esta web.

Dicho esto, podemos empezar el an치lisis. Actualmente el lenguaje de programaci칩n mas popular es **Python**, seguido de **C** y **C++**. Un detalle importante es que el top 5 de lenguajes (Python, C, C++, Java, C#) acapara el 50% de la popularidad en el mundo de la programaci칩n. Esto quiere decir que tan solo 5 lenguajes tienen la misma popularidad que los 45 restantes que conforman el indice TIOBE(realmente est치 compuesto por 50 lenguajes pero solo hemos representado los 20 m치s importantes).

Nuestro querido **R** se sit칰a en la **posici칩n 20** y aunque parezca desolador, R est치 compitiendo en este 칤ndice contra otros lenguajes que son utilizados para otras funciones totalmente diferentes (para las cu치les R no ha sido dise침ado desde un principio). No obstante si hablamos de programar con estad칤stica, econometr칤a o similares(es decir cosas que hace un economista) **no hay otro lenguaje como R** y es imprescindible tener un buen manejo del mismo para ser un buen economista (no usen SPSS).

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true
#| warning: false

df <- top_20()
df <-  df %>% select(1,4,5)
df <- df %>%
  mutate(porcentaje_numeric = ifelse(str_detect(Ratings, "%"),
                                     as.numeric(str_remove(Ratings, "%")),
                                     as.numeric(Ratings))) %>%
  rename(cuota = porcentaje_numeric) %>%
  select(1,2,4)
 

colores <- c("#3498db", "#2ecc71", "#e74c3c", "#f39c12", "#9b59b6", "#e67e22", "#1abc9c", "#95a5a6")

df_logos <- data.frame(lenguaje = c("Python", "C", "C++", "Java", "C#", "JavaScript", "PHP", "Visual Basic", "SQL", "Assembly language", "Scratch", "Fortran", "Go", "MATLAB", "Kotlin", "Delphi/Object Pascal", "Swift","Ruby","R","Rust"),
                       logo = c("https://tse4.mm.bing.net/th?id=OIP.EDJ9xoErBbZqK2tExVoJfAAAAA&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.bkbn2-K7c9rMBV5dvYXDrQHaIh&pid=Api&rs=1&c=1&qlt=95&w=103&h=118","https://tse1.mm.bing.net/th?id=OIP.ggb-3B-8LRfbgS0lPLYNxwHaIU&pid=Api&rs=1&c=1&qlt=95&w=105&h=118","https://tse1.mm.bing.net/th?id=OIP.dJ7A1hPb-BDRBrhOmhrVAgHaHa&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.2x1yN8k3MVCrkJFR_C5k-wHaIp&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.YPYdVAg5ieRspLI6HIpmDQHaIB&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.pkqphAig1t-PCsy4dkVrfAHaD5&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.Y224uoZnCs8yY0Sos_h4cQHaDd&pid=Api&rs=1&c=1&qlt=95&w=258&h=120","https://tse4.mm.bing.net/th?id=OIP.S_9pgiKacbi3FxPKxDmusgHaFy&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.v5m2HW3FI3RbopnK8Cs6HgAAAA&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.bHt6sdtkwUqP91oPKlruGgHaEM&pid=Api&P=0&h=180","https://tse2.explicit.bing.net/th?id=OIP.tLfIejOZiP_H0Zse0NIn2QAAAA&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.7nKR4oRAhgtSbD97mDXWWgHaE8&pid=Api&P=0&h=180","https://tse2.mm.bing.net/th?id=OIP.cI8KflTKlnmraGFa22XpKQHaEK&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.gW_YaXsZmuSntd_sy5zkIwHaHa&pid=Api&P=0&h=180","https://tse2.mm.bing.net/th?id=OIP.hEP7hOlvIzhKU1fGpizd7QAAAA&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.XozeB5BRQSzNCO6k7om62QHaHa&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.2BwE10YiTSXRrnW2LnVh8wHaHa&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.0rg-o4mEzLO5EHJ1zS52YwHaGe&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.YmPfYoQK3WvGEjFXusKV9QHaHa&pid=Api&P=0&h=180"))

df_final <- left_join(df, df_logos, by = c(`Programming Language` = "lenguaje"))
df_final <- df_final %>% mutate(Logo = logo, .after = `Programming Language`)
df_final <- df_final %>% select(-5)

tabla_tiobe <- gt(df_final) %>% 
  gtExtras::gt_plt_dot(column = cuota, category_column = `Programming Language`,  max_value = NULL, palette = colores ) %>% 
  gtExtras::gt_theme_nytimes() %>% 
  tab_header(title = "Lenguajes de programaci칩n m치s populares",
             subtitle = "Seg칰n el 칤ndice TIOBE.") %>% 
  cols_width(`Programming Language` ~ px(368), 3 ~ px(30)) %>%
  gtExtras::gt_img_rows(columns = Logo, img_source = 'web')

#- tabla_tiobe

```

## Gr치fico

```{r}
#| code-fold: true
tabla_tiobe
```
:::

<br>

En el siguiente gr치fico[^1] podemos observar una evoluci칩n comparada del top 10 lenguajes de programaci칩n. La mayor칤a de programas(C, C++, Java, JavaScript, etc) se han mantenido en el top 10 desde los inicios de la serie, sin embargo, es especialmente interesante la evolucion de dos lenguajes: **Python y SQL**.

[^1]: En el gr치fico se representa la *posici칩n promedio* para el peri칩do de 12 meses

Como ya bien sabemos Python es posiblemente el *GOAT* en cuanto a lenguajes de programaci칩n y se puede observar en su ascenso en el ranking desde la posici칩n 22 en el a침o 1993 a ser el n칰mero 1 en 2023.

Por otro lado, a pesar de que SQL(*Structure Query Language*) es un lenguaje antiguo, se introdujo en el 칤ndice por primera vez en 2003(manteni칠ndose por tan solo un a침o) y no volvi칩 a entrar en el 칤ndice hasta el a침o 2018. Desde entonces ha tenido un crecimiento sin precedentes debido debido al boom del BigData ya que este lenguaje permite manipular, obtener datos e incluso crear bases de datos. SQL es utilizado en todos aquellos sectores donde sea necesario manejar datos y empresas como Spotify o Facebook lo utilizan para almacenar informaci칩n de sus usuarios.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true
#| warning: false
#| message: false

df_2 <- long_term_history()
df_2 <- df_2 %>% pivot_longer(cols = 2:9, names_to = "a침o", values_to = "posicion")
df_2 <- df_2 %>% mutate(posicion =  as.numeric(posicion),
                        a침o = as.numeric(a침o))

df_python <- df_2 %>% filter(`Programming Language` == "Python")
df_c <- df_2 %>% filter(`Programming Language` == "C")
df_cplus <- df_2 %>% filter(`Programming Language` == "C++")
df_cplus <- df_2 %>% filter(`Programming Language` == "C++")
df_java <- df_2 %>% filter(`Programming Language` == "Java")
df_javasc <- df_2 %>% filter(`Programming Language` == "JavaScript")
df_csharp <- df_2 %>% filter(`Programming Language` == "C#")
df_csharp <- df_2 %>% filter(`Programming Language` == "C#")
df_php <- df_2 %>% filter(`Programming Language` == "PHP")
df_vb <- df_2 %>% filter(`Programming Language` == "Visual Basic")
df_sql <- df_2 %>% filter(`Programming Language` == "SQL")
df_asm <- df_2 %>% filter(`Programming Language` == "Assembly language")


plot_top <- highchart() %>%
  hc_chart(type = "line") %>%
  hc_add_series(df_python, "line", hcaes(a침o, posicion), name = "Python") %>%
  hc_add_series(df_c, "line", hcaes(a침o, posicion), name = "C") %>%
  hc_add_series(df_cplus, "line", hcaes(a침o, posicion), name = "C++") %>%
  hc_add_series(df_java, "line", hcaes(a침o, posicion), name = "Java") %>%
  hc_add_series(df_javasc, "line", hcaes(a침o, posicion), name = "JavaScript") %>%
  hc_add_series(df_csharp, "line", hcaes(a침o, posicion), name = "C#") %>%
  hc_add_series(df_php, "line", hcaes(a침o, posicion), name = "PHP") %>%
  hc_add_series(df_vb, "line", hcaes(a침o, posicion), name = "Visual Basic") %>%
  hc_add_series(df_sql, "line", hcaes(a침o, posicion), name = "SQL") %>%
  hc_add_series(df_asm, "line", hcaes(a침o, posicion), name = "Assembly Language") %>%
  hc_title(text = "Evoluci칩n del Top 10 lenguajes de programaci칩n",
           style = list(fontWeight = "bold",
                        color = "#333")) %>%
  hc_xAxis(title = list(text = NULL)) %>%
  hc_yAxis(title = list(text = "Posici칩n 칤ndice TIOBE")) %>%
  hc_yAxis(reversed = TRUE) %>%
  hc_tooltip(pointFormat = "({point.x}, {point.y})") 

#- plot_top

```

## Gr치fico

```{r}
#| code-fold: true
plot_top
```
:::

<br>

A continuaci칩n hemos realizado una tabla con el *Hall of Fame* de lenguajes de programacion. En este caso la comunidad TIOBE otorga el premio de *"Mejor lenguaje del a침o"* no a aquel que mas popularidad tiene, sino a qui칠n mayor incremento de rating ha tenido.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true
#| warning: false


df_3 <-hall_of_fame()

df_logo <- data.frame(lenguaje = c(2022:2003),
                      logo = c("https://th.bing.com/th?id=OIP.H3I3buZeC8Bkez8ADSrqMwHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.uZuulMpBtfWNUBXf8fHu1AHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.uZuulMpBtfWNUBXf8fHu1AHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.bkbn2-K7c9rMBV5dvYXDrQHaIh&w=233&h=268&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.uZuulMpBtfWNUBXf8fHu1AHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.bkbn2-K7c9rMBV5dvYXDrQHaIh&w=233&h=268&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.7nKR4oRAhgtSbD97mDXWWgHaE8&w=306&h=204&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP._Lm_T3scKhVEVFC54gcRxwHaE8&w=306&h=204&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.Y4VPmWW2m4_V2WFYOEGYRgHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://www.bing.com/th?id=OIP.LN_XZYfNR1okCsPl0pzIqQAAAA&w=114&h=100&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.rI4h3ndENsvdOwunJgW4aQAAAA&w=212&h=212&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.rI4h3ndENsvdOwunJgW4aQAAAA&w=212&h=212&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.uZuulMpBtfWNUBXf8fHu1AHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.7nKR4oRAhgtSbD97mDXWWgHaE8&w=306&h=204&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.bkbn2-K7c9rMBV5dvYXDrQHaIh&w=233&h=268&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.uZuulMpBtfWNUBXf8fHu1AHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.MWdAq1cI3bRY5--dtqIwJwHaHY&w=250&h=249&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP._Lm_T3scKhVEVFC54gcRxwHaE8&w=306&h=204&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.uhYWKsUDBf1rPMjzWZx3OgHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2","https://th.bing.com/th?id=OIP.H3I3buZeC8Bkez8ADSrqMwHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2"))

df_gt <- left_join(df_logo,df_3, by = c("lenguaje" = "Year")) %>%
  rename(Year = lenguaje)
df_gt <- df_gt %>% rename(A침o = Year,
                          Ganador = Winner)



tabla_hallfame <- gt(df_gt) %>%
  gtExtras::gt_color_rows( A침o,palette = "viridis", pal_type = "continuous") %>%
  gtExtras::gt_img_rows(columns = logo, img_source = 'web') %>%
  tab_header(title = "Mejor lenguaje de programaci칩n de cada a침o",
             subtitle = "Seg칰n el 칤ndice TIOBE") %>%
  gtExtras::gt_theme_538()

#- tabla_hallfame

```

## Gr치fico

```{r}
#| code-fold: true

tabla_hallfame
```
:::

<br>

Python es el lenguaje m치s laureado con un total de 5 premios, cifra muy superior a la del resto de sus competidores. En segundo lugar se encuentra C con 3 premios(cabe destacar que tanto Python como C son los dos lenguajes con m치s premios y a su vez los m치s populares en la actualidad). Finalmente compartiendo la 칰ltima posici칩n del podio se hayan Objective-C, Go, Java y C++ todos con 2 premios.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true
#| warning: false

df_3 <-hall_of_fame()

df_3 <- df_3 %>% rename( Ganador = `Winner`) %>%
  group_by(Ganador) %>%
  count(n()) %>%
  select(1,3) %>%
  rename(numero_premios = n )


p_winners <- ggplot()+ 
  geom_bar(data = df_3, aes(x = fct_reorder(Ganador, numero_premios), y = numero_premios ,fill = Ganador), stat = "identity") + 
  theme_clean() + 
  labs(title = "N칰mero de premios a Mejor Lenguaje del a침o",
       caption = "Fuente: Elaboraci칩n propia a partir del 칤ndice TIOBE",
       y = NULL,
       x = NULL) + 
  theme(legend.position = "none",
        axis.text.y = element_text(size = 12, face = "bold")) +
  scale_fill_brewer(palette = "Paired") + coord_flip()

#- p_winners

```

## Gr치fico

```{r}
#| code-fold: true

p_winners
```
:::

# Encuesta de Stack Overflow

La Encuesta de Desarrolladores de Stack Overflow es una encuesta anual que realiza la plataforma de preguntas y respuestas centrada en la programaci칩n y el desarrollo de software. Esta encuesta es una de las mayores y m치s completas en la industria de la tecnolog칤a, recopila datos de desarrolladores de todo el mundo y cubre una amplia gama de temas.

Por esta raz칩n, parece muy razonable atender a los datos que nos provee esta encuesta para poder responder a determinadas preguntas de inter칠s sobre los lenguajes de programaci칩n y su contexto social en el mundo.

## 쮺on qu칠 lenguajes suelen comenzar los j칩venes que empiezan carrera en la programaci칩n?

Una de las preguntas que m치s interesa a la hora de aprender a programar es precisamente esta: **쯖on qu칠 lenguaje empezar a programar?**. Especialmente son aquellos m치s j칩venes que deciden iniciarse en el mundo de la programaci칩n o el desarrollo de software quienes se hacen m치s a menudo esta pregunta.

Para hacer frente a esta cuesti칩n, hemos descargado e instalado en una carpeta dentro del project los datos en formato .csv de la encuesta. En ella, aparecen decenas de miles de observaciones y distintas variables, de las cuales, daremos m치s importancia a dos: la franja de edad, que en este caso son los j칩venes de 18 a 24 a침os, y los diez lenguajes m치s populares. De esta manera, obtendremos una lista de lenguajes ordenados de menor a mayor seg칰n el uso que se le de en esta franja de edad.

Primero, cargamos los datos y los arreglamos para poder trabajar con ellos.

```{r}
#| code-fold: true

my_ruta <- here::here("datos", "survey_results_public.csv.zip")
df <- rio::import(my_ruta)
df <- df %>%  
  select(Age , LanguageHaveWorkedWith) %>% 
  separate_rows(LanguageHaveWorkedWith, sep = ";\\s*")
df1 <- df %>% filter(Age == "18-24 years old") %>% 
  filter(!is.na(LanguageHaveWorkedWith)) %>% 
  group_by(LanguageHaveWorkedWith) %>%
  summarise(Observaciones = n()) %>% 
  top_n(10, Observaciones) %>% 
  arrange
df1

```

Una vez tenemos los datos ordenados en un data.frame, hacemos un gr치fico de barras con ayuda de ggplot2.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true

colores <- c("#3498db", "#2ecc71", "#e74c3c", "#f39c12", "#9b59b6", "#e67e22", "#1abc9c","#33FF99","#95a5a6", "#FFCCFF")

diez_mas_usados <- ggplot(df1, aes(x = reorder(LanguageHaveWorkedWith, Observaciones), y = Observaciones)) +
  geom_bar(stat = "identity", fill = colores) +
  labs(title = "Top 10 Lenguajes de Programaci칩n para Personas de 18-24 a침os",
       x = "Lenguajes de Programaci칩n",
       y = "N칰mero de Observaciones") +
  theme_minimal() +
  theme(axis.title = element_blank(),
        axis.text.x = element_text(size = 8, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 8),
        plot.title = element_text(size = 12, face = "bold"),
        plot.subtitle = element_text(size = 10)) +
  labs(title = "Lenguajes de programaci칩n con los que se inician los j칩venes",
       subtitle = "medido en n칰mero de respuestas a la encuesta",
       caption = "Fuente: encuesta anual de Stack Overflow") +
  guides(fill = FALSE) + # Eliminar la leyenda de la est칠tica fill
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
#- diez_mas_usados
```

## Gr치fico

```{r}
#| code-fold: true

diez_mas_usados
```
:::

Representamos as칤 que los j칩venes, a la edad en la que usualmente empiezan a hacer carrera dentro de la programaci칩n, o incluso si simplemente quieren estudiar por la pura satisfacci칩n de conocimiento, eligen con especial preferencia tres lenguajes: JavaScript, Python y HTML/CSS, destacando el primero de los mencionados.

Los j칩venes a menudo eligen aprender **JavaScript** porque es un lenguaje de programaci칩n vers치til y ampliamente asentado ya en la comunidad. JavaScript se utiliza por ejemplo en el desarrollo web para crear interactividad en las p치ginas, lo que lo hace atractivo para aquellos interesados en la creaci칩n de sitios web din치micos. Adem치s, es un lenguaje accesible para principiantes, tiene una comunidad activa que comparte recursos educativos y ofrece oportunidades laborales en el 치mbito del desarrollo web.

## 쮺u치l es el lenguaje de programaci칩n m치s popular para cada grupo de edad?

Ahora, aunque podamos ver cuales son aquellos lenguajes m치s populares tanto en la poblaci칩n general como en el caso concreto de los j칩venes principiantes, sigue siendo interesante se침alar cuales son los **lenguajes favoritos** de los usuarios respecto a **distintas franjas de edad**, para conocer m치s o menos el perfil medio de un programador cualquiera con determinados a침os de edad.

Para esta pregunta haremos valer una **tabla**, no un gr치fico al uso a lo ggplot2. Despu칠s de cargar paquetes, arreglamos el data.frame original para poder trabajar c칩modamente con 칠l.

```{r}
#| code-fold: true

#De nuevo, lo primero que haremos ser치 cargar los paquetes necesarios.

df2 <- df %>%
  filter(!is.na(LanguageHaveWorkedWith)) %>%
  group_by(Age, LanguageHaveWorkedWith) %>%
  summarise(Observaciones = n()) %>%
  group_by(Age) %>%
  top_n(1, Observaciones) %>%
  arrange(Age, desc(Observaciones)) %>% 
  select(-Observaciones) %>% 
  rename(lenguaje = LanguageHaveWorkedWith)
df2
```

Tenemos el data.frame ordenado, falta a침adirle m치s cosas para poder hacer una tabla que exprese mejor los resultados, tales como una paleta de colores e iconos de los lenguajes.

```{r}
#| code-fold: true

df_logos <- data.frame(lenguaje = c("Python", "C", "C++", "Java", "C#", "JavaScript", "PHP", "Visual Basic", "SQL", "Assembly language", "Scratch", "Fortran", "Go", "MATLAB", "Kotlin", "Delphi/Object Pascal", "Swift","Ruby","R","Rust", "Golang"),
                       logo = c("https://tse4.mm.bing.net/th?id=OIP.EDJ9xoErBbZqK2tExVoJfAAAAA&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.bkbn2-K7c9rMBV5dvYXDrQHaIh&pid=Api&rs=1&c=1&qlt=95&w=103&h=118","https://tse1.mm.bing.net/th?id=OIP.ggb-3B-8LRfbgS0lPLYNxwHaIU&pid=Api&rs=1&c=1&qlt=95&w=105&h=118","https://tse1.mm.bing.net/th?id=OIP.dJ7A1hPb-BDRBrhOmhrVAgHaHa&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.2x1yN8k3MVCrkJFR_C5k-wHaIp&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.YPYdVAg5ieRspLI6HIpmDQHaIB&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.pkqphAig1t-PCsy4dkVrfAHaD5&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.Y224uoZnCs8yY0Sos_h4cQHaDd&pid=Api&rs=1&c=1&qlt=95&w=258&h=120","https://tse4.mm.bing.net/th?id=OIP.S_9pgiKacbi3FxPKxDmusgHaFy&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.v5m2HW3FI3RbopnK8Cs6HgAAAA&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.bHt6sdtkwUqP91oPKlruGgHaEM&pid=Api&P=0&h=180","https://tse2.explicit.bing.net/th?id=OIP.tLfIejOZiP_H0Zse0NIn2QAAAA&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.7nKR4oRAhgtSbD97mDXWWgHaE8&pid=Api&P=0&h=180","https://tse2.mm.bing.net/th?id=OIP.cI8KflTKlnmraGFa22XpKQHaEK&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.gW_YaXsZmuSntd_sy5zkIwHaHa&pid=Api&P=0&h=180","https://tse2.mm.bing.net/th?id=OIP.hEP7hOlvIzhKU1fGpizd7QAAAA&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.XozeB5BRQSzNCO6k7om62QHaHa&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.2BwE10YiTSXRrnW2LnVh8wHaHa&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.0rg-o4mEzLO5EHJ1zS52YwHaGe&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.YmPfYoQK3WvGEjFXusKV9QHaHa&pid=Api&P=0&h=180", "https://seeklogo.com/images/G/go-logo-046185B647-seeklogo.com.png"))
df2_final <- left_join(df2, df_logos, by = ("lenguaje"))
#El data.frame daba problemas as칤 que lo he rehecho con un poco de ayuda de R base.
ages <- df2_final$Age
lenguajes <- df2_final$lenguaje
logos <- df2_final$logo
dataframef2_final <- data.frame(ages, lenguajes, logos)
```

Ahora s칤, creamos la tabla con ayuda del paquete gt.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true

gt_tbl <- dataframef2_final %>%
  gt() %>% 
  gtExtras::gt_theme_espn() %>%
  cols_width("lenguajes" ~ px(100), "logos" ~ px(80)) %>% 
  tab_header(title = "Lenguajes de programaci칩n m치s populares por franjas de edad",
             subtitle = "Seg칰n la encuesta anual de Stack Overflow.")%>%
  gtExtras::gt_img_rows(columns = logos, img_source = 'web')

#- gt_tbl
```

## Gr치fico

```{r}
#| code-fold: true

gt_tbl
```
:::

Los resultados son evidentes: JavaScript arrasa en la mayor칤a de las edades por las mismas razones que ya hemos expuesto en la pregunta anterior. Adem치s, es un lenguaje ya muy consolidado a lo largo de los a침os, como podemos ver por su prevalencia incluso en programadores senior.

## 쮺uales son los medios m치s comunes con los que las personas aprenden a programar?

La programaci칩n consiste en un conjunto de conocimientos, herramientas y habilidades que permiten al usuario llevar a cabo el proceso de crear un **conjunto de instrucciones que le dicen a una computadora como realizar alg칰n tipo de tarea**. Todos estos elementos de aprendizaje son muy diversos y no hay una, ni dos, ni tres 칰nicas maneras de aprenderlos.

As칤 pues, tambi칠n nos parece que abordar cuales son las **principales fuentes de estudio** de aquellos que tienen intenci칩n o incluso han logrado alcanzar dichas destrezas es algo que suma bastante a nuestro trabajo.

De nuevo, cargamos datos y "limpiamos" el data.frame.

```{r}
#| code-fold: true

my_ruta <- here::here("datos", "survey_results_public.csv.zip")
df <- rio::import(my_ruta)
df <- df %>% 
  select(LearnCode) %>% 
  rename(learn=LearnCode) %>% 
  separate_rows(learn, sep = ";\\s*") %>% 
  drop_na() %>% 
  group_by(learn) %>% 
  summarise(Observaciones = n()) %>% 
  arrange(desc(Observaciones)) %>% 
  filter(learn != "Other (please specify):")
```

Ahora que tenemos los datos ordenados en un data.frame, podemos hacer una tabla que muestre de forma clara los resultados obtenidos.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true

colores <- c("#3498db", "#2ecc71", "#e74c3c", "#f39c12", "#9b59b6", "#e67e22", "#1abc9c","#33FF99", "#FFCCFF")
gt_df <- gt(df) %>%
  gtExtras::gt_plt_dot(column = "Observaciones", category_column = `learn`,  
                       max_value = NULL, palette = colores) %>%
  gtExtras::gt_theme_nytimes() %>%
  cols_width(`learn` ~ px(400), 2 ~ px(150)) %>% 
  tab_header(title = "Maneras m치s usuales que se usan para aprender programaci칩n",
             subtitle = "Seg칰n la encuesta anual de Stack Overflow.")
#- gt_df
```

## Gr치fico

```{r}
#| code-fold: true

gt_df
```
:::

El resultado es muy interesante. Si bien el aprendizaje mediante medios f칤sicos o m치s tradicionales como libros y programas educativos en universidades y centros sigue estando en la cabeza de la lista, en el primer puesto est치 nada m치s y nada menos que el **aprendizaje por recursos en l칤nea**.

Esto al final 칰nicamente evidencia la tendencia que podemos haber ido notando desde inicios de siglo, sobre todo durante la 칰ltima d칠cada y m치s aun tras la pandemia. Cada vez son m치s los alumnos que aprenden **v칤a telem치tica** a trav칠s de trabajos, blogs y v칤deos en la red, y, como cab칤a de esperar de los alumnos de un sector tan ligado a la tecnolog칤a, los programadores no se han quedado atr치s en esta tendencia, siendo que incluso el aprendizaje por cursos certificados est치 a muy corta distancia por debajo del aprendizaje en la universidad.

## 쮺uales son los lenguajes cuyo manejo brinda mayores salarios en promedio?

La respuesta a esta pregunta est치 en unos datos que no son de esta encuesta, los hemos obtenido de una web distinta, pero lo incluimos en esta secci칩n porque creemos que est치 muy relacionado con la tem치tica de importancia y contexto socio econ칩mico de los lenguajes de programaci칩n. De esta forma, primero cargamos los datos y a침adimos elementos que nos favorecer치n el hacer una tabla que muestre los datos ordenados, de mayor a menor salario mediano.

```{r}
#| code-fold: true

my_ruta2 <- here::here("datos","lista_lenguajes_mejor_pagados.xlsx")
aa <- rio::import(my_ruta2)
aa <- aa %>% select(-"Number of Jobs")
df_logos <- data.frame(lenguaje = c("Python", "C", "C++", "Java", "C#", "JavaScript", "PHP", "Visual Basic", "SQL", "Assembly language", "Scratch", "Fortran", "Go", "MATLAB", "Kotlin", "Delphi/Object Pascal", "Swift","Ruby","R","Rust", "Golang"),
                       logo = c("https://tse4.mm.bing.net/th?id=OIP.EDJ9xoErBbZqK2tExVoJfAAAAA&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.bkbn2-K7c9rMBV5dvYXDrQHaIh&pid=Api&rs=1&c=1&qlt=95&w=103&h=118","https://tse1.mm.bing.net/th?id=OIP.ggb-3B-8LRfbgS0lPLYNxwHaIU&pid=Api&rs=1&c=1&qlt=95&w=105&h=118","https://tse1.mm.bing.net/th?id=OIP.dJ7A1hPb-BDRBrhOmhrVAgHaHa&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.2x1yN8k3MVCrkJFR_C5k-wHaIp&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.YPYdVAg5ieRspLI6HIpmDQHaIB&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.pkqphAig1t-PCsy4dkVrfAHaD5&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.Y224uoZnCs8yY0Sos_h4cQHaDd&pid=Api&rs=1&c=1&qlt=95&w=258&h=120","https://tse4.mm.bing.net/th?id=OIP.S_9pgiKacbi3FxPKxDmusgHaFy&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.v5m2HW3FI3RbopnK8Cs6HgAAAA&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.bHt6sdtkwUqP91oPKlruGgHaEM&pid=Api&P=0&h=180","https://tse2.explicit.bing.net/th?id=OIP.tLfIejOZiP_H0Zse0NIn2QAAAA&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.7nKR4oRAhgtSbD97mDXWWgHaE8&pid=Api&P=0&h=180","https://tse2.mm.bing.net/th?id=OIP.cI8KflTKlnmraGFa22XpKQHaEK&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.gW_YaXsZmuSntd_sy5zkIwHaHa&pid=Api&P=0&h=180","https://tse2.mm.bing.net/th?id=OIP.hEP7hOlvIzhKU1fGpizd7QAAAA&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.XozeB5BRQSzNCO6k7om62QHaHa&pid=Api&P=0&h=180","https://tse1.mm.bing.net/th?id=OIP.2BwE10YiTSXRrnW2LnVh8wHaHa&pid=Api&P=0&h=180","https://tse3.mm.bing.net/th?id=OIP.0rg-o4mEzLO5EHJ1zS52YwHaGe&pid=Api&P=0&h=180","https://tse4.mm.bing.net/th?id=OIP.YmPfYoQK3WvGEjFXusKV9QHaHa&pid=Api&P=0&h=180", "https://seeklogo.com/images/G/go-logo-046185B647-seeklogo.com.png"))
my_ruta2 <- here::here("datos","lista_lenguajes_mejor_pagados.xlsx")
aa <- rio::import(my_ruta2)
aa <- aa %>% select(-"Number of Jobs") %>% 
  rename(lenguaje = Language)
df_final <- left_join(aa, df_logos, by = ("lenguaje"))
```

Ahora que tenemos el data.frame listo para trabajar con el, componemos la tabla.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true

colores <- c("#3498db", "#2ecc71", "#e74c3c", "#f39c12", "#9b59b6", "#e67e22", "#1abc9c","#33FF99","#95a5a6", "#FFCCFF")

gt_salarios <- gt(df_final) %>%
  gtExtras::gt_plt_dot(column = "Median Salary ($)", category_column = `lenguaje`,  
                       max_value = NULL, palette = colores) %>%
  gtExtras::gt_theme_espn() %>%
  cols_width(`lenguaje` ~ px(400), 3 ~ px(80)) %>% 
  tab_header(title = "Lenguajes de programaci칩n con mejores salarios",
             subtitle = "Seg칰n la web 4 day week.") %>%
  gtExtras::gt_img_rows(columns = logo, img_source = 'web')
#- gt_salarios
```

## Gr치fico

```{r}
#| code-fold: true

gt_salarios
```
:::

La primera conclusi칩n m치s o menos evidente es la siguiente: en el sector de la programaci칩n, *los salarios parecen ser relativamente altos*. Ahora bien, destaca que el lenguaje cuyo manejo est치 mejor remunerado no es aquel m치s popular en ninguna franja de edad, *SWIP* es un lenguaje creado por Apple enfocado al desarrollo de aplicaciones para iOS y macOS, el ecosistema de la empresa mencionada.Swift puede llamar a funciones de C y tiene la intenci칩n de ser un lenguaje con alta seguridad y con un desarrollo r치pido y preciso. Adem치s, es de c칩digo abierto.

# Programaci칩n en Econom칤a

De un tiempo a esta parte, los economistas hemos conseguido interiorizar una idea: la programaci칩n es una de las habilidades fundamentales que tenemos que dominar a la hora de realizar cualquier tipo de an치lisis econ칩mico m칤nimamente avanzando. En este sentido, nuestro objetivo es mostrar dos ejemplos de como saber programar (en el primer caso, en varios lenguajes, mientras que en el segundo caso, lo haremos en R) es un requisito *sine qua non* para realizar determinadas tareas medianamente b치sicas. Es cierto que uno puede defenderse en algunas de estas tareas (a veces con m치s 칠xito y otras con menos) con ciertos programas como Stata, Eviews, SPSS, etc. Pero, al final del d칤a, cuando uno quiere obtener la soluci칩n de un modelo din치mico de equilibrio general (macroeconom칤a) o conocer la caracterizaci칩n de un equilibrio en teor칤a de juegos (microeconom칤a), tendr치 que programar de verdad, porque ah칤, los programas de clics (que algunos, adem치s, cuestan una millonada) no sirven para nada (obviando que si sirviesen har칤an an치lisis no reproducible, no solo porque no son open source y adem치s de pago, sino porque la din치mica de clicar lo hace inviable).

## Estimando un modelo estoc치stico neocl치sico de crecimiento.

Para analizar la velocidad de computaci칩n de diferentes lenguajes de programaci칩n en Econom칤a podemos estimar un mismo modelo en varios lenguajes y comprobar el desempe침o de cada uno de ellos; esto, evidentemente, no se nos ha ocurrido a nosotros, de hecho, un economista que ha trabajado bastante con estas cosas es Jes칰s Fern치ndez-Villaverde, nosotros los que hemos hecho es seleccionar uno de sus papers[^2] para poder comparar la velocidad de computaci칩n de un modelo estoc치stico neocl치sico de crecimiento. Antes de dar los resultados, vamos a explicar brevemente en que consiste el modelo y por qu칠 es una tarea ciertamente demandante en t칠rminos de computaci칩n. Tranquilos, no entraremos en detalles y se podr치 entender bien la idea general, quien quiera se puede leer el paper, nosotros solo explicaremos lo b치sico.

[^2]: "Aruoba, S. B., & Fern치ndez-Villaverde, J. (2015). A comparison of programming languages in macroeconomics. Journal of Economic Dynamics and Control, 58, 265-273."

Es cierto que el modelo mola bastante (no es broma), b치sicamente porque es una s칤ntesis de como se hace macroeconom칤a actualmente: iterando funciones. Tanto es as칤, que el propio Villaverde escribe en el asbtract del paper que es "the workhorse of modern macroeconomics", y bueno, si lo dice 칠l, ser치 verdad (recordemos que es un tipo bastante listo, o eso parece, al menos). La idea del modelo es bastante sencilla de entender: un planificador social tiene que maximizar un funci칩n de valor escogiendo una combinaci칩n de consumo $c_t$ y capital $k_t$. La funci칩n se maximizar치 cuando se alcance el valor 칩ptimo de capital futuro:

$$\max_{\{c_t, k_t+1\}}\mathbb{E}_0\sum_{t=0}^{\infty}(1 - \beta)\beta^t\log c_t$$ La $\mathbb{E}$ es el operador de expectativas, mientras que el par치metro $\beta$ simplemente es un factor de descuento temporal, ahora bien, esta funci칩n est치 sujeta a la siguiente restricci칩n de recursos: $$c_t + k_{t+1} = z_tk_{t}^\alpha + (1 - \delta)k_t$$ Dos apuntes m치s y terminamos (prometido): $z_t$ es la productividad, y sus valores se situar치n en un intervalo de puntos discretos $\{z_1,..., z_n\}$ que evolucionan de acuerdo a una matriz de transici칩n de Markov $\prod$. Despu칠s de unos ajustes y de calibrar los par치metros, formulamos el problema de maximizaci칩n de manera recursiva en t칠rminos de la funci칩n de valor $V(.,.)$ con un operador de Bellman, de manera que finalmente tenemos el problema que nuestro ordenador tendr치 que resolver: $$V(k,z) = \max_{k'}(1 - \beta)\beta^t\log(zk^\alpha-k')+\beta\mathbb{E}[V(k',z')|z]$$ El problema es ciertamente demandante, para que la funci칩n converga a su valor 칩ptimo se han realizado (en todos los lenguajes) 257 iteraciones, usando 17.820 puntos para $k$ uniformemente distribuidos en torno al 50 por ciento del valor en estado estacionario del capital $k$. Los puntos de $k$ se han escogido de manera que en `C++`y `Fortran` pueda resolverse el problema en, m치s o menos, un segundo.

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true

ex_times <- readxl::read_excel("./datos/execution_times.xlsx") #-importamos la tabla del pdf del paper a una hoja de c치lculo, la cargamos, y ya trabajamos con ella en R

ex_times <- ex_times %>%  
  select(1, 4) %>% 
  na.omit() 

colnames(ex_times) <- c("Lenguajes", "times")
ex_times <- ex_times[2:9,] 

ex_times <- ex_times %>% 
  mutate(times = parse_number(times))

ex_times <- ex_times %>%
  mutate(category = case_when(
    as.numeric(times) < 3 ~ "Menos de 3 seg",
    as.numeric(times) >= 3 & as.numeric(times) < 60 ~ "Entre 3 y 60 seg",
    as.numeric(times) >= 60 ~ "M치s de 60 seg",
    TRUE ~ NA_character_)) 

ex_times$factor_cat <- as.factor(ex_times$category)
orden_correcto <- c("Menos de 3 seg", "Entre 3 y 60 seg", "M치s de 60 seg")
ex_times$factor_cat <- factor(ex_times$category, levels = orden_correcto)

ex_times_plot <- ex_times %>% 
  ggplot() +
  aes(x = Lenguajes, y = times, fill = Lenguajes)  +
  geom_bar(stat = "identity") +
  facet_wrap(~factor_cat, scales = "free") +
  theme_stata(scheme = "s1color") +
  labs(title = "Tiempos de ejecuci칩n del modelo", x = "", y = "Tiempo en segundos")
```

## Gr치fico

```{r}
#| code-fold: true

ex_times_plot
```
:::

En el paper ejecutan el modelo en todos los lenguajes en dos ordenadores: un Mac y un Windows, adem치s de usar diferentes compiladores; para no entrar en detalles t칠cncos, escogemos el compilador de cada lenguaje que m치s r치pido ejecuta el c칩digo y, adem치s, seleccionamos los tiempos de ejecuci칩n del Mac, b치sicamente porque un servidor est치 usando uno ahora mismo y porque los tiempos no cambian demasiado, a excepci칩n de: Fortran, que tarda el doble (dos segundos en lugar de uno), R que tarda unos 40 segundos menos y Mathematica que tarda casi 200 segundos menos.

Lo primero que observamos es que los lenguajes que mejor desempe침o presentan (menos de 3 segundos en ejecutarse) son los compilados, junto a Julia, que es interpretado. El caso de Julia es interesante, su sint치xis es muy similar a la de Matlab, usa un compilador JIT que lo hace bastante r치pido (entre otras caracter칤sticas bastante guais que tiene), puede llamar a funciones de C o de Fortran sin necesidad de usar APIs y, bueno, es gratis, Matlab no (adem치s los a침os ya le pasan factura y su interfaz est치 desfasada, por otro lado pensemos que Julia naci칩 en 2012). Despu칠s, tenemos a Matlab, que tarda unos 10 segundos en ejecutarse, y a Python, que tarda algo m치s de 40 segundos. Dejando de lado que Mathematica es el 칰ltimo (y con diferencia) y que no me interesa hablar de 칠l porque una vez lo us칠 y (casi) me toc칩 venderle mi alma al diablo para hacer una gr치fica bastante sencilla, podemos centrarnos en R.

Si usamos el `R compiler package` sigue siendo 200 veces m치s lento que el lenguaje m치s r치pido (en el peor de los casos lo ser칤a casi 500 veces), esto tiene una explicaci칩n y hemos de ser comprensivos, el dise침o original de R (de los a침os 90) y determinadas decisiones (de las que no tengo mucha idea) que se tomaron en ese momento, junto a la 칠xito inesperado que ha terminado teniendo en la actualidad, pueden dificultar seg칰n qu칠 tareas. Pero bueno, tampoco pasa nada, la realidad es que nadie m치s que cuatro frikis usan R para resolver este tipo de modelos, de hecho, hasta hace aproximadamente una semana y tres d칤as (es broma, hasta septiembre de este mismo a침o), ni siquiera se pod칤an estimar modelos de equilibrio general en R como se har칤a en el resto de lenguajes, ahora tenemos el paquete [`DynareR`](https://cran.r-project.org/web/packages/DynareR/index.html) que nos facilita muuuucho la tarea, de hecho, est치 ideado espec칤ficamente para resolver modelos `DSGE` (dynamic stochastic general equilibrium) y `OLG` (overlapping generations), habr치 que ver que pasa en un futuro. Como iba diciendo, nadie usa R para estas cosas, donde realmente brilla es en estad칤stica y econometr칤a (ahora tocaremos este tema), ya que, solamente en el repositorio CRAN, hay casi 20.000 paquetes diferentes para estas dos 치reas.

En suma, el biling칲ismo, al menos en lo que a programaci칩n en Econom칤a se refiere, es altamente recomendable, fundamentalmente porque las ventajas a la hora de realizar determinadas tareas son enormes en lenguaje respecto a otro, asimismo, los lenguajes evolucionan, lo que hoy se usa puede que ma침ana no, y lo que no se usa, posiblemente ma침ana s칤. La cuesti칩n es ser conscientes de que cada lenguaje es una herramienta diferente y cuantas m치s herramientas tengamos, mejor podremos solucionar los problemas que nos vayamos encontrando en nuestro camino como economistas.

## Una miqueta de Econometr칤a

Una vez hemos analizado como se comportan los diferentes lenguajes, podemos hacer un (mini) an치lisis con R, al final, R est치 dise침ado para ser la herramienta excelente a la hora de hacer estad칤stica y econometr칤a, entre otras cosas. Esta vez haremos algo un poquito m치s manejable que el modelo de antes, vamos a estimar la funci칩n de producci칩n Cobb-Douglas en el caso de Espa침a. Vamos a usar los datos de las Penn World Table, y con eso, hacemos una regresi칩n por MCO. Esto, a parte de ser cutre, evidentemente generar치 problemas, nosotros nos vamos a centrarnos en analizar el problema de autocorrelaci칩n, el lector deber칤a saber que es esto (Pedro, sabemos de sobra que t칰 ya lo sabes, no te ofendas por la explicaci칩n) y yo no deber칤a explicarlo, pero como nunca se sabe, haremos un repaso r치pido.

Cuando estimamos los par치metros de un modelo por min칤mos cuadrados ordinarios buscamos que nuestros estimadores cumplan unas caracter칤sticas b치sicas, si se cumplen, nuestro estimador ser치 ELIO (estimador lineal insesgado 칩ptimo), o BLUE, por sus siglas en ingl칠s. Ahora bien, entre los miles de millones de problemas que podemos tener a la hora de estimar un modelo por MCO, hay uno en concreto que puede tocarnos ~~las pelotas~~ la moral como no lo tratemos adecuadamente, y este es la autocorrelaci칩n. B치sicamente, nuestro modelo presentar치 autocorrelaci칩n cuando los residuos guarden alg칰n tipo de patr칩n entre ellos, y por movidas matem치ticas y estad칤sticas varias, esto har치 que nuestro estimador no sea 칩ptimo.

Nuestro objetivo es doble: mostraros una manera un poco de andar por casa para detectar la autocorrelaci칩n y, de manera breve, como se puede hacer Econometr칤a con R de manera sencilla y sin morir en el intento.

Lo primero de todo es coger los datos, moldearlos para que est칠n en un formato amigable y estimar el siguiente modelo: $$\ln(PIB_t) = \beta_1 + \beta_2\ln(L) + \beta_3\ln(K) + u_t$$ Alg칰n lector avispado ya sabr치 el significado de la $L$ y de la $K$, a parte de eso, como ya hemos explicado lo b치sico de MCO y de autocorrelaci칩n, la explicaci칩n de por qu칠 pasamos las variables a logaritmos no va a estar presente (en serio, si hace falta explicar eso, ya no ten칠is opciones de salvaci칩n, solamente os pod칠is arrepentir de vuestros pecados, it's over for you游游):

```{r, warning=FALSE}
#| code-fold: true

#Modelo econom칠trico ----------

df <- read.csv("./datos/FebPwtExport12152023.csv")
#- pasamos los datos a formato wide
df <- dcast(df, RegionCode + YearCode ~ VariableCode, value.var = "AggValue")
#- cambiamos el nombre a uno m치s familiar y creamos la variable trabajo y filtramos los datos a partir del 78
df <- df %>% 
  mutate(l = avh*emp) %>% 
  rename(k = rnna,
         pib = rgdpna,
         year = YearCode) %>% 
  filter(year >= 1960)

modelo <- lm(log(pib) ~ log(l) + log(k), data = df)
#- stargazer(modelo, type = "html")
```

<table style="text-align:center"><tr><td colspan="2" style="border-bottom: 1px solid black"></td></tr><tr><td style="text-align:left"></td><td><em>Dependent variable:</em></td></tr>
<tr><td></td><td colspan="1" style="border-bottom: 1px solid black"></td></tr>
<tr><td style="text-align:left"></td><td>log(pib)</td></tr>
<tr><td colspan="2" style="border-bottom: 1px solid black"></td></tr><tr><td style="text-align:left">log(l)</td><td>0.212<sup>***</sup></td></tr>
<tr><td style="text-align:left"></td><td>(0.041)</td></tr>
<tr><td style="text-align:left"></td><td></td></tr>
<tr><td style="text-align:left">log(k)</td><td>0.747<sup>***</sup></td></tr>
<tr><td style="text-align:left"></td><td>(0.008)</td></tr>
<tr><td style="text-align:left"></td><td></td></tr>
<tr><td style="text-align:left">Constant</td><td>0.112</td></tr>
<tr><td style="text-align:left"></td><td>(0.372)</td></tr>
<tr><td style="text-align:left"></td><td></td></tr>
<tr><td colspan="2" style="border-bottom: 1px solid black"></td></tr><tr><td style="text-align:left">Observations</td><td>60</td></tr>
<tr><td style="text-align:left">R<sup>2</sup></td><td>0.995</td></tr>
<tr><td style="text-align:left">Adjusted R<sup>2</sup></td><td>0.995</td></tr>
<tr><td style="text-align:left">Residual Std. Error</td><td>0.038 (df = 57)</td></tr>
<tr><td style="text-align:left">F Statistic</td><td>5,635.315<sup>***</sup> (df = 2; 57)</td></tr>
<tr><td colspan="2" style="border-bottom: 1px solid black"></td></tr><tr><td style="text-align:left"><em>Note:</em></td><td style="text-align:right"><sup>*</sup>p<0.1; <sup>**</sup>p<0.05; <sup>***</sup>p<0.01</td></tr>
</table>



Una vez tenemos el modelo estimado y, habi칠ndonos saltado cualquier tipo de interpretaci칩n estad칤stica de los datos (seamos realistas, no es el momento para ponernos a hacer estas cosas, aqu칤 se nos valora por programar), podemos pasar a detectar la autocorrelaci칩n.

Vamos a hacerlo de manera gr치fica, y una vez veamos indicios de no autocorrelaci칩n, autocorrelaci칩n positiva, o autocorrelaci칩n negativa, vamos a estimar el par치metro que usamos para medirla, que como sabr칠is, es $\rho$, en nuestro caso ser치 $\rho_1$.

Primero, podemos plottear la dispersi칩n de los residuos con sus valores rezagados:

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true

df_residuos <- data.frame(x = lag(resid(modelo)), y = resid(modelo)) %>% 
  na.omit()

autocorrelacion <- df_residuos %>% 
  ggplot() +
  geom_point(color = "red") +
  aes(x = x, y = y) +
  labs(title = "Dispersi칩n de los residuos del modelo", 
       x = "Residuos rezagados",
       y = "Residuos") +
  theme_clean() + 
  geom_smooth(se = FALSE, method = lm)
#- autocorrelacion
```

## Gr치fico

```{r}
#| code-fold: true

autocorrelacion
```
:::

Vemos que, evidentemente, existe autocorrelaci칩n positiva, cuando una varibale crece, la otra tambi칠n lo hace. Sabiendo esto, tambi칠n podemos plottear los residuos en una serie temporal para detectar patrones:

::: panel-tabset
## C칩digo

```{r}
#| code-fold: true

autocorrelaci칩n_plot <- df %>% 
  ggplot() + 
  geom_point(color = "#5D8AA8") +
  geom_line(color = "#69b3a2") +
  aes(x = year, y = resid(modelo)) +
  labs(title = "Residuos del modelo", 
       x = "A침o",
       y = "Residuos") +
  geom_hline(yintercept = 0, color = "orange", size=.5) +
  theme_classic()
#- autocorrelaci칩n_plot  
```

## Gr치fico

```{r}
#| code-fold: true

autocorrelaci칩n_plot  
```
:::

Vemos que el modelo muestra patrones en los residuos que se presentan regularmente a lo largo de determinados intervalos de tiempo. Cuando los intervalos de tiempo en los que se da este patr칩n son de una duraci칩n notable, observamos indicios de que la autocorrelaci칩n es positiva, pues si el valor del residuo es alto en un momento dado, es muy probable que tambi칠n sea alto en el momento posterior.

Teniendo pruebas suficientes del car치cter de la autocorrleaci칩n, finalmente, de manera un poco rudimentaria e improvisada (sin usar el test Durbin Watson, el Llung-Box o alguno de los varios que hay), podemos estimar el valor del coeficiente de autocorreelaci칩n $\rho_1$, sabiendo, eso s칤, que ser치 un n칰mero entre 0 y 1. B치sicamente, calculamos una regresi칩n usando como regeresor los residuos rezagados del modelo, mientras que la variable explicada ser치n los residuos (a secas). En el c칩digo especificamos que no queremos intercepto y, te칩ricamente, deber칤amos tener el valor estimado del coeficiente de autocorrelaci칩n.

```{r}
#| code-fold: true

rho <- lm(resid(modelo) ~ lag(resid(modelo))-1)
rho <- as.numeric(rho$coefficients)
rho
```

Podemos comprobar r치pidamente que el valor estimado de $\rho_1=0.7641839$ es consistente con los dos an치lisis gr치ficos que hemos hecho previamente sobre los residuos, por lo que la conclusi칩n ser치 la misma: autocorrelaci칩n positiva y estimaci칩n no 칩ptima, nuestros estimadores MCO no ser치n BLUE. Pero no pasa nada, el profe podr치 proponer un modelo alternativo que no tenga este problema, mientras tanto, yo dejo por aqu칤 esta canci칩n, que s칤 que es blue 游땔.

```{r}
#| echo = FALSE,
#| out.width = "100%"
embed_url("https://www.youtube.com/watch?v=zA52uNzx7Y4&ab_channel=malawolf85")
```

# Conclusi칩n

Con este trabajo hemos querido destacar la importancia que tiene la programaci칩n en la econom칤a, fundamentalmente en el 치mbito de la investigaci칩n. Nos parece importante resaltar las cualidades que tiene poseer estas herramientas como profesional en este campo, pues mientras se suele dar por obvia la necesidad de saber programar en estudios como las matem치ticas o las ciencias puras, usualmente se ignora las necesidades que puede tener un economista de aprender programaci칩n para ejercer con rigor y efectividad su trabajo, hasta el punto en el que nuestra propia universidad no ofrec칤a esta asignatura hace un lustro.

Por eso, gran parte de este trabajo, adem치s de demostrar las virtudes de la aplicaci칩n de conocimientos sobre programaci칩n en la investigaci칩n econ칩mica, ha ido dirigido a explicar en rasgos generales cuales son los lenguajes m치s populares y los que con mayor frecuenecia se suelen utilizar seg칰n determinados contextos, tales como la edad o el salario esperado. Tambi칠n hemos querido se침alar m칠todos y fuentes comunes con las que los alumnos, desde los m치s novatos a los m치s expertos suelen acudir para aprender sobre programaci칩n o para resolver las dudas que puedan surgir en el proceso de desarrollo.

Por 칰ltimo, creemos que este conjunto de conocimientos y herramientas no es simplemente importante, sino que es indispensable para nuestra formaci칩n como economistas de calidad, y si bien apreciamos haber dado esta asignatura este a침o, creemos que no es suficiente con una asignatura optativa en el 칰ltimo a침o de carrera, que lo 칩ptimo ser칤a darla en los primeros a침os del grado, para poder dedicar los posteriores a pulir en la pr치ctica los conocimientos adquiridos, y m치s adelante, a expandirlos (machine learning, I.A, deep learning, etc.).

# Referencias

-   ["Aruoba, S. B., & Fern치ndez-Villaverde, J. (2015). A comparison of programming languages in macroeconomics. Journal of Economic Dynamics and Control, 58, 265-273."](https://www.sas.upenn.edu/~jesusfv/comparison_languages.pdf)

-   [TIOBE Index](https://www.tiobe.com/tiobe-index/)

-   [Stack Overflow Developer Survey 2023](https://survey.stackoverflow.co/2023/)

<br>
<br>
<br>
<br>
<br>

Abajo muestro mi entorno de trabajo y los paquetes utilizados

```{r}
#| echo: false
sessioninfo::session_info() %>% 
  details::details(summary = 'current session info') 
```
